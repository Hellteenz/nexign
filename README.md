# Описание задания №1:
Все звонки, совершенные абонентом сотового оператора, фиксируются в CDR файлы, которые собираются на коммутаторах. Когда абонент находится в роуминге за процесс сбора его данных отвечает обслуживающая сеть абонента. 
Для стандартизации данных между разными операторами международная ассоциация GSMA ввела стандарт BCE. Согласно ему, данные с CDR должны агрегировать в единый отчет UDR, который впоследствии передается оператору, 
обслуживающему абонента в домашней сети. На основе этого отчета, домашний оператор выставляет абоненту счет.

В рамках задания, CDR будут содержать записи следующего вида:
- тип вызова (01 - исходящие, 02 - входящие);
- номер абонента;
- дата и время начала звонка (Unix time);
- дата и время окончания звонка;
- разделитель данных – запятая;
- разделитель записей – перенос строки;
- данные обязательно формируются в хронологическом порядке;
- В рамках задания CDR может быть обычным txt;

# Задача:
Написать сервис, эмулирующий работу коммутатора, т.е. генерирующий CDR файлы.
Условия:
1.       1 CDR = 1 месяц. Тарифицируемый период в рамках задания - 1 год;
2.       Данные в CDR идут не по порядку, т.е. записи по одному абоненту могут быть в разных частях файла;
3.       Количество и длительность звонков определяется случайным образом;
4.       Установленный список абонентов (не менее 10) хранится в локальной БД (h2);
5.       После генерации CDR, данные о транзакциях пользователя помещаются в соседнюю таблицу этой БД.


# Описание решения задания №1:
Для реализации тарифицируемого периода был выбран временной промежуток в 10 лет (01.01.2014 - 17.03.2024), также выставлены ограничения на время разговора: 60 секунд - минимальное (списание денег/тарифного плана поминутное), 30 минут (1800 секунд) - максимальное (у многих операторов есть ограничения на разговор меж разными операторами СС в 30 минут).

Далее было произведено подключение к локальной базе данных через поле класса.

Используются два вспомогательных класса:
1. В ConnectionH2 описана функция для установки соединения, позже используется в основном классе.
2. В FileCreator описаны процедуры и функции создания пустого файла .txt с нужным порядковым номером и получение пути до этого файла.

Для формирования CDR файлов был использован метод ***generateCDR***. Через цикл for проходимся 12 раз (т.к. 1 год по условию задания), где вызываем следующие методы: 
1. Процедура очистки базы данных.
2. Процедура создания одного CDR файла.
3. Процедура заполнения таблицы в базе данных.

Метод ***resetCDRTable*** нужен, чтобы удостовериться, что в новый CDR не запишется лишней информации, поэтому таблица удаляется и создается заново при каждом новом проходе. Используются методы класса Connection.

Процедура ***createCDR_DB*** использует функции того же класса Connection и отправляет commit в базу данных с новой информацией. Но прежде чем отправлять, CDR файл походит все возможные проверки:
как пример - функция ***insertCDRFile*** обрабатывает файл на наличие ошибок в пути, а ***insertStr*** уже непосредственно формирует запрос БД на заполнение очередной строки, тем временем ***addToPack*** собирает всю информацию на хранение, чтобы потом один разом погрузить ее файл.

***GenerateCurrCDR*** отвечает за создание одного конкретного CDR файла. Здесь же используется функция ***createFile*** из вспомогательного класса. Функция напрямую зависит от метода ***generateCurrStr***, в котором происходит построчное формирование CDR-файла, буквально записывая имеющиеся знания о пользователе через запятую. 
Случайные номера же получались из списка случайных в методе ***getRandPhoneNum*** через подключение к исходной локальной базе данных, а в процедуре ***getOnePhoneNum*** описан непосредственно SQL-запрос в таблицу. Последней микро-функцией является ***getRandomType***, где происходит правильное оформление типа вызова.
